
""" Cинтаксис функции map """
""" Функция map используется для применения функции к каждому элементу итерируемого объекта 
(например, списка или словаря). Результатом будет итератор map object. """
# Документация к функции map
# class map(object)
#    map(func, *iterables) --> map object
"""Здесь говорится о том, что эта функция принимает два параметра: функцию и итерабельную последовательность. 
    Результатом будет объект следующего типа map object: он представляет собой итератор, который вычисляет 
    результат работы переданной функции на каждый аргумент из итерабельной последовательности."""

""" Какие функции можно передавать в map:
    -Встроенные функции
    -Пользовательские функции
    -Методы объектов
    -Анонимные функции"""
list_strings = ['hello', 'hi', 'good morning']
b = list(map(lambda x: x[::-1], list_strings))
print(b) # ['olleh', 'ih', 'gninrom doog']
# То же самое можно делать и при помощи генератора списка:
a = ['hello', 'hi', 'good morning']
b = [i[::-1] for i in a]
print(b) # ['olleh', 'ih', 'gninrom doog']
# Функция lambda достаточно многофункциональна, с её помощью можно, допустим, добавить какие-либо символы,
# например, восклицательный знак.
list_strings = ['hello', 'hi', 'good morning']
b = list(map(lambda x: x+'!', list_strings))
print(b) # ['hello!', 'hi!', 'good morning!']

"""  Функция map может принимать несколько последовательностей """
""" class map(object)
 |  map(func, *iterables) --> map object
 |  
 |  Создайте итератор, который вычисляет функцию, используя аргументы из
 | каждой из итераций. Останавливается, когда исчерпывается самая короткая итерация."""

"""знак звездочки перед iterables говорит о том, что функция map может принимать произвольное количество 
последовательностей. В таком случае будут браться по порядку элементы стоящие на одинаковых местах из всех коллекций и 
по очереди передаваться на вход функции func. 
Количество параметров функции func должно совпадать с количеством последовательностей."""
def power(base: int, exp: int) -> int:
    return base * exp
bases = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] # список чисел
exponents = [1, 2, 3, 4, 5] # список множетелей
result = list(map(power, bases, exponents)) # передадим функцию и обе последовательности
print(result) # [10, 40, 90, 160, 250]
# Данный пример можно было реализовать при помощи встроенной функции pow
bases = [10, 20, 30, 40, 50]
exponents = [1, 2, 3, 4, 5]
result = list(map(pow, bases, exponents))
print(result) # -> [10, 400, 27000, 2560000, 312500000]
# Вот пример с тремя коллекциями и функцией lambda, в которой мы принимаем три значения и возвращаем сумму
nums1 = [1, 2, 3]
nums2 = [4, 5, 6]
nums3 = [7, 8, 9]
result = map(lambda x, y, z: x + y + z, nums1, nums2, nums3)
print(list(result)) # -> [12, 15, 18]


""" Несколько примеров """
# Список из строк можно преобразовывать в список из списков символов.
from pprint import pprint
list_strings = ['hello', 'hi', 'good morning']
b = list(map(list, list_strings))
pprint(b)
print(b) # [['h', 'e', 'l', 'l', 'o'], ['h', 'i'], ['g', 'o', 'o', 'd', ' ', 'm', 'o', 'r', 'n', 'i', 'n', 'g']]
# Таким образом, при помощи функции map мы не только перевели строки в списки, но и отсортировали их.
words = list(map(sorted, b))
print(*words) # ['e', 'h', 'l', 'l', 'o'] ['h', 'i'] [' ', 'd', 'g', 'g', 'i', 'm', 'n', 'n', 'o', 'o', 'o', 'r']


# Ваша задача преобразовать каждый элемент списка numbers в строку
numbers = [116, -411, 448, 278, 118, -462, -671, 78, -69, -568, -228, -445, -47, -565]
strings = list(map(str,numbers))
print(strings) # ['116', '-411', '448', '278', '118', '-462', '-671', '78', '-69', '-568', '-228', '-445', '-47']


# Ваша задача увеличить каждый элемент списка numbers втрое
numbers = [116, -411, 448, 636, -671, 78, -69, -568, -228, -445, -47, -565]
increase_3 = list(map(lambda x: x*3,numbers)) # передадим в лямбду, где и увеличим
print(increase_3) # [348, -1233, 1344, 1908, -2013, 234, -207, -1704, -684, -1335, -141, -1695]


# на вход закодированный код цвета в формате RGB и возвращает кортеж из трех значений
# from_hex_to_rgb(#000000) => (0, 0, 0)
# from_hex_to_rgb(#FFFFFF) => (255, 255, 255)
def from_hex_to_rgb(color: str) -> tuple:
    color=color.lstrip('#') # получим 87CEEB код RGB без #,т.е. убираем не нужный символ, можно сделать и через срез
    return tuple(int(color[i:i + 2], 16) for i in (0, 2, 4)) # здесь берётся срез по два элемента из строки и преобразуется в число из 16-ной системы
colors = ['#B22222', '#DC143C', '#FF0000', '#FF6347', '#FF7F50', '#CD5C5C', '#F08080', '#E9967A']
for red, green, blue in map(from_hex_to_rgb, colors): # каждый оттенок закидываем в функцию
    print(f"Red={red}, Green={green}, Blue={blue}") # -> Red=178, Green=34, Blue=34 и т.д.
print()
print(int('B2',16)) # -> 178 так преобразуется в шестнадцатеричную систему
"""Второй аргумент, который вы передаете функции int, указывает, какую систему счисления использовать для интерпретации строки. 
В случае шестнадцатеричной системы счисления, это значение обычно устанавливается на 16. 
Для восьмеричной системы счисления, это значение будет 8, а для двоичной - 2."""


# Сформировать список кортежей разных регистров
s = 'M e S s I'
print([(i.upper(),i.lower()) for i in s.split()]) # -> [('M', 'm'), ('E', 'e'), ('S', 's'), ('S', 's'), ('I', 'i')]


# список кортежей превратить в список строк по парам
names = [('Gerald', 'Tucker'), ('Tricia', 'Johnson'), ('Robert', 'Mendez')]
new_names = list(map(lambda x: x[0]+' '+x[1],names))
print(new_names)  # -> ['Gerald Tucker', 'Tricia Johnson', 'Robert Mendez']


# на основании списка persons отобрать информацию о номерах телефона и сложить их в отдельный список
persons = [
    {
        'birthday': '1983-10-25',
        'job': 'Field seismologist',
        'name': 'Andrew Hernandez',
        'phone': '680-436-8521x3468'
    },
    {
        'birthday': '1993-10-03',
        'job': 'Pathologist',
        'name': 'Paul Harmon',
        'phone': '602.518.4130'
    }
]
phones = list(map(lambda x: x['phone'], persons))
print(phones) # -> ['680-436-8521x3468', '602.518.4130']









