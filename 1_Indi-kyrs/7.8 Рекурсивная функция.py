
""" Рекурсия в программировании - ситуация, когда функция вызывает саму себя.
    В python глубина рекурсии приблизительно 1000, т.е. около тысячи раз функция может вызвать саму себя.
    У рекурсии обязательно должен быть выход, т.е. такое условие,
     при соблюдении которого функция перестает вызывать саму себя.
    """
def rec(x):
    if x < 4: # по достижению условия функция перестанет себя вызывать
        print(x)
        rec(x+1) # вызов функции из самой функции
        print(x)
rec(1) # вызов функции
print('------------------')


""" ----------- Рекурсивная факториала ----------- """

"""самый простой случай, это нахождение факториала единицы - это и будет наш выход из рекурсии. 
При всех остальных случаях, когда n>1, мы должны применять рекурсивную формулу n!=(n−1)!∗n"""
def fuc(n):  # рекурсия факториал от большего к меньшему
    if n==1:
        return 1
    return fuc(n-1)*n
print(f'факториал {5} равен {fuc(5)}')
print('------------------')

def f(n): # рекурсия от нуля до числа
    if n<4: # условие выхода(обязательно должно быть)
        print(f'идём вперёд {n}')
        f(n+1)
        print(f'идём назад {n}') # после того как дойдёт до последней функции идём обратно(обратная последовательность)
f(0)
print('------------------')


""" ----------- Число фибоначи ----------- """
"""Числа Фибоначчи – представляют собой ряд чисел, первые из которых = 0 и 1, дальнейшие числа = сумме двух предыдущих чисел"""
def fib(n:int)->int: # число фибоначи это сложение двух предыдущих чисел, данная программа актуальна только для маленьких чисел
    if n==1:
        return 0
    if n==2:
        return 1
    return fib(n-1)+fib(n-2)
print(f'число фибаначи от {5} порядка равно {fib(5)}')
print('------------------')


""" ----------- Пример с проверкой является ли слово палиндромом или нет ----------- """
"""Здесь идёт сравнение первого и последнего символа"""
def is_palindrom(word):
    if len(word)<=1: return True
    elif word[0]!=word[-1]: return False
    return is_palindrom(word[1:-1])
print(is_palindrom('шалаш'))
print('------------------')


""" ----------- Двойной факториал ----------- """
def double_fact(n:int)->None:
    if n==1: return 1
    if n == 2: return 2
    return double_fact(n-2)*n
print(double_fact(6)) # -> 48
print('------------------')


""" ----------- Числа Трибоначчи ----------- """
def tribonacci(n:int)->int:
    if n==0: return 0
    if n ==1: return 0
    if n ==2: return 1
    return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3)
print(tribonacci(8)) # -> 24
print('------------------')



def get_combin(n:int, k:int)->int:
    if k==0: return 1
    if k == n: return 1
    return get_combin(n-1,k)+get_combin(n-1,k-1)
print(get_combin(10,7)) # -> 120
print('------------------')


""" ----------- Функция Аккермана ----------- """
def ackermann(m:int, n:int)->int:
    if m==0: return n+1
    if m >0 and n == 0: return ackermann(m-1,1)
    return ackermann(m-1,ackermann(m,n-1))  # 7
print(ackermann(3,2)) # -> 29
print('------------------')


""" ----------- Алгаритм Сортировка слиянием ----------- """
# функция merge_two_list должна объединить два списка
def merge_two_list(a:list, b:list)->list:
    c = [] # создадим новый пустой список который и вернём
    i = j = 0 # индекс элемента в списках
    while i < len(a) and j < len(b): # если в обоих списках есть числа
        if a[i] < b[j]: # и элемент из второй список больше элемента из первого списка
            c.append(a[i]) # то в новый список добавляем указанный элемент из первого списка
            i += 1 # и увеличиваем индекс первого списка на 1
        else:
            c.append(b[j]) # если наоборот
            j += 1  #  увеличиваем индекс второго списка на 1
    if i < len(a): # если длинна первого списка больше индекса первого списка
        c += a[i:] # то мы в новый список добавляем оставшиеся элементы из первого списка
    if j < len(b): # тоже самое для второго списка
        c += b[j:]
    return c
# функция merge_sort должна выполнить сортировку
def merge_sort(s:list)->list: # полученный списко делим попалам пока не полим по одному элементу в двух списках,
                              # и передаем их на сравнение в выше стоящую функцию
    if len(s) == 1:
        return s
    middle = len(s) // 2
    left = merge_sort(s[:middle])
    right = merge_sort(s[middle:])
    return merge_two_list(left,right)
print(merge_sort(merge_two_list([7],[6,2,19,5,10,7,11])))


""" Быстрая сортировка - еще один вид сортировки, который использует рекурсию.  """
# функция quick_sort должна выполнить сортировку
def quick_sort(s): # получаем исходный список
    if len(s)<=1:
        return s
    elem = s[0] # выделяем опорный элемент
    lst1 = [i for i in s if i<elem] # если меньше опорного числа, то первый список
    lst2 = [i for i in s if i==elem] # если равен ему - то второй список
    lst3 = [i for i in s if i>elem] # если больше его - то третий список
    return quick_sort(lst1)+lst2+quick_sort(lst3) # рекурсивно вызовем функции с передачей всех список
a = [8]  # опорный элемент на который будем ссылаться при сортировки
b = [16,19, 2, 12, 20, 15, 20, 15] # список что нужно отсортировать
print(quick_sort(a+b))


'''Рекурсивный обход файлов'''
import os
path = 'E:\\док' #  путь к нашей корневой папке
def scan_dir(path, level=1):
    print('Level=', level, 'Content:', os.listdir(path))
    for i in os.listdir(path): # обойдём все папка в указанном пути
        if os.path.isdir(path + '\\' + i): # os.path.isdir(путь и имя папки нужно) если это папка то будет True
            print('Спускаемся', path + '\\' + i)
            scan_dir(path + '\\' + i, level + 1) # повторный вызов функции с указанием нового адреса и уровня
            print('Возвращаемся в', path)
scan_dir(path)


""" ----------- ЗАДАНИЯ ----------- """
""" - №1 Дано натуральное число N и последовательность из N элементов. 
    Требуется вывести эту последовательность в обратном порядке.
    Во второй строке через пробел идут N целых чисел.
    Ваша задача вывести заданную последовательность в обратном порядке."""
n = input() # 3
print(*list(map(int, input().split()))[::-1],sep=' ' ) # 1 2 3 -> 3 2 1


""" - №2 Напишите функцию, которая принимает на вход список из целых чисел и возвращает сумму элементов 
    переданного списка. Не забывайте, что реализовать это нужно при помощи рекурсии. """
def list_sum_recursive(lst:list)->int:
    if len(lst)==1: return lst[0]
    return lst[0]+list_sum_recursive(lst[1:])
print(list_sum_recursive((1,2,3))) # -> 6


""" - №3 Превращаем вложенные списоки в плоский"""
# flatten([1, [2, 3, [4]], 5]) => [1, 2, 3, 4, 5]
def flatten(lst: list) -> list:
    if not lst: # если список пустой, то возвращаем пустой список
        return []
    if isinstance(lst[0],list): # элемент является списком, то этот элемент кидаем снова в функцию, как и остальную часть
        return flatten(lst[0])+flatten(lst[1:])
    return lst[:1] + flatten(lst[1:]) # если не пустой и не список, то отщипываем элемент, а остальное в рекурсию
# lst[:1] позволяет взять нулевой элемент, т.е. lst[0], но обернёт его в список через срез,
# т.к. вернувшееся число со списком не складывается !!!!!!!!!!!!!!

print(flatten([1, [2, 3], [[2], 5], 6])) # -> [1, 2, 3, 2, 5, 6]


""" - №4 Превращаем вложенные словари в плоский """
def flatten_dict(nested_dict={}, flatten=None):
    if flatten is None: # если не было пустого словаря
        flatten = {} # то создадим его
    for key, value in nested_dict.items():
        if isinstance(value, dict):
            flatten_dict({f'{key}_{sub_key}': sub_value for sub_key, sub_value in value.items()}, flatten)
        else:
            flatten[key] = value
    return flatten
nested = {'Germany': {'berlin': 7},
          'Europe': {'italy': {'Rome': 3}},
          'USA': {'washington': 1, 'New York': 4}}
print(flatten_dict(nested))

""" - №5 Добавить открывающуюся и закрывающуюся скобки """
a = '1234' * 4
b = '123' * 5
def f(x):
    if len(x) == 2 or len(x) == 1: # если один или два элемента, то вернём обратно
        return x[:]
    return x[0] + '(' + f(x[1:-1]) + ')' + x[-1]
print(f(a)) # -> 1(2(3(4(1(2(3(41)2)3)4)1)2)3)4
print(f(b)) # -> 1(2(3(1(2(3(1(2)3)1)2)3)1)2)3


""" - №6 сделать зеркальное отражение списка """
a = '5(((1((2(3((45((((('
def f(x):
    if x[0] == '(' and len(x)>1:
        return x[0] + f(x[1:]) + ')'
    if len(x) == 1 and x[0]!='(':
        return x+x
    if len(x) == 1 and x[0]=='(':
        return x[0]+')'
    return x[0] + f(x[1:]) + x[0]
print(f(a)) # -> 5(((1((2(3((45((((()))))54))3)2))1)))5

""" - №7 возведение в степень через рекурсию """
def f(x,n):
    if n==0:# если степень нулевая
        return 1
    if n<0: # если степень отрицательная
        return 1/f(x,-n)
    if n%2==0:# если степень чётная
        return f(x,n//2)*f(x,n//2)
    return x*f(x,n-1)# если степень нечётная
print(f(2,10)) # -> 1024
print(f(2,-10)) # -> 0.0009765625


''' - №8 Нумеролог - суммировать числа и определить уровень сложения'''
x = '14101945'  # число жизни в секундах
def f(a, level=0):
    if len(a) == 1:  # если одна цифра
        return int(a), level
    if len(a) > 1:  # если больше одной цифры
        level += 1
        return f(str(sum(list(map(int, a)))), level)
i,level = f(x)  # выведем через пробел
print(f'итог суммирования чисел - {i}, уровень сложения - {level}')