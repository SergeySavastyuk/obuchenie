
"""sort - это метод только для списка, а sorted - это встроенная функция позволяющая сортировать почти все объекты"""

""" Кратко, sort – метод списка, соответственно, используется только к спискам. 
    При его вызове ваш список автоматически изменится и никакого присваивания делать не нужно. 
    
    Функция sorted представляет собой встроенную функцию, которой можно передавать любую итерабельную 
    последовательность и она также будет выполнять сортировку, но при этом, не меняя изначальную последовательность, 
    для замены начальной коллекции необходимо прибегнуть к присваиванию. """


a = [10,-5,2,0,9,3,-1,-4,6,-5]
b = 'мама мыла раму'
c = ('шла', 'саша', 'по', 'шоссе')
print('метод sort/sorted сортирует объект в порядке возрастания по умолчанию')
print(f'до метода sort {a}')
a.sort() # !!!! Изменяет первоначальный список
print(f'после метода sort {a}')
print('1'*60,end='\n'*2)

print('после применения функции sorted()') # НЕ Изменяет первоначальный список
print(sorted(a))
print(sorted(b))
print(sorted(c))
print('2'*60,end='\n'*2)

print('параметр reverse определяет в каком порядке будеть сортировка')
# c = sorted(c key = function, reverse = False/True)
# a.sort( key = function, reverse = False/True)
print(f'исходая строка: {b}')
print(sorted(b, reverse=True))
print(sorted(b, reverse=False))
print('3'*60,end='\n'*2)


print('аргумент KEY в сортировке, МОЖЕТ содержать встроенную или свою функцию')
# print(sorted(a,key=function))   аргумент KEY МОЖЕТ содержать встроенную или свою функцию
a = [100,-50,20,0,95,31,-154,-4732,6342,-50]
print(f'исходый список: {a}')
print(sorted(a,key=abs),' - сортировка по модулю')  # сортировка по модулю
def f(x):
    return x%10 # сортировка по последней цифре числа по возрастанию
print(sorted(a,key=f), ' - сортировка по последней цифре числа по возрастанию')

def f(x):
    return -(x%10) # сортировка по последней цифре числа по убыванию
print(sorted(a,key=f), ' - сортировка по последней цифре числа по убыванию')

def f(x):
    return x%10, x//10%10 # сортировка по последней цифре, если равны то по предпоследней цифре числа по возрастанию
print(sorted(a,key=f), ' - сортировка по последней цифре, если равны то по предпоследней цифре числа по возрастанию')
print('4'*60,end='\n'*2)

print('аргумент KEY МОЖЕТ содержать методы объектов')
a = ['WW','fff','AAA']
print(f'исходый список: {a}')
print(sorted(a), ' - сортировка по регистру букв')  # сортировка по регистру букв
print(sorted(a,key=str.lower), ' - сначала все буквы станут маленькими, а потом будет сортировка по регистру')
print('5'*60,end='\n'*2)

print('аргумент KEY МОЖЕТ содержать анонимные функции')
a = ['WW 800','ff 45','aaa 43','hhhh 800','k 21', 'aaa 21']
print(f'исходый список: {a}')
print(sorted(a, key=lambda x: int(x.split()[1])),' - разделим по пробелу, потом возьмем второй элемент и превратим его '
                                                 'в число, после по нему будет сортировка по возрастанию')
print(sorted(a, key=lambda x: ( int(x.split()[1]), x.split()[0].lower())),' - двойная сортировка, сначала по числам, '
                                                                          'а если равны, то по алфавиту (из двух ответов для функции делаем кортеж)')
print(sorted(a, key=lambda x: ( int(x.split()[1]), x.split()[0].lower()), reverse=True),' - в обратную сторону')
print(sorted(a, key=lambda x: ( x.split()[0].lower(), int(x.split()[1]))),' - сортировка сначала по букве, потом по числу')
print(sorted(a, key=lambda x: ( int(x.split()[1]))),' - сначала отсортируем по числам по возрастанию')
print(sorted(a, key=lambda x:  x.split()[0].lower(), reverse=True  ),' - потом по строкам в обратной последовательности')
print('6'*60,end='\n'*2)


"""  Как отсортировать словарь  """
heroes = {'Spider-Man': 80,'Batman': 65,'Wonder Woman': 70,'Flash': 70,'Aquaman': 65,'Hulk': 87}

for key in sorted(heroes): # наши ключи теперь отсортированы в алфавитном порядке.
    print(key, heroes[key], end=', ') # Aquaman 65, Batman 65, Flash 70, Hulk 87, Spider-Man 80, Wonder Woman 70,
print()
print()

# сортировку по значениям
print(*sorted(heroes.items(),key=lambda x:x[1])) # ('Batman', 65) ('Aquaman', 65) ('Wonder Woman', 70) ('Flash', 70) ('Spider-Man', 80) ('Hulk', 87)

""" ЗАДАЧИ """

""" №1 отсортирует список models по цвету в лексикографическом порядке (по алфавиту) """
models = [{'make': 'Nokia', 'model': 216, 'color': 'Black'},
          {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},
          {'make': 'Samsung', 'model': 7, 'color': 'Blue'},
          {'make': 'Apple', 'model': 10, 'color': 'Silver'},
          {'make': 'Oppo', 'model': 9, 'color': 'Red'},
          {'make': 'Huawei', 'model': 4, 'color': 'Grey'},
          {'make': 'Honor', 'model': 3, 'color': 'Black'}]
models2 =  sorted(models,key=lambda x: x['color'])
print(*[f"Производитель: {models2[i]['make']}, модель: {models2[i]['model']}, цвет: {models2[i]['color']}"  for i in range(len(models2))],sep='\n')


""" №2 вывести список товаров по уменьшению цены"""
# Sony PlayStation 5: 46000
# Телевизор QLED Samsung QE65Q60TAU: 87090
# Смартфон Samsung Galaxy A11: 10000
# Планшет Samsung Galaxy Tab S6: 26600
# конец
goods = {}
while True:
    s = input()
    if s == 'конец':
        break
    else:
        goods[s.split(': ')[0]]= int(s.split(': ')[1])  # разобьём строку на две части по двоеточию с пробелом,
                                                        # и добавим в новый словарь как ключь со сначением
[print(k) for k,v in sorted(goods.items(), key=lambda item: -item[1])] # отсортируем словарь по значению и выведем ключи


""" №3 Нужно вывести в отдельных строках имена актеров набравших наибольшее и наименьшее количество статуэток"""
# 6
# Леонардо Ди Каприо
# Джонни Депп
# Леонардо Ди Каприо
# Леонардо Ди Каприо
# Джонни Депп
# Мэтт Деймон
base = {}
for i in range(int(input())):
    name = input()
    base[name] = base.get(name, 0) + 1 # добавим в словарь имена с количеством нужных статуэток
base = sorted(base.items(), key=lambda item: -item[1]) # отсортируем по значению в обратную сторону
# обратившись по индексу в словарь получаем кортеж из двух элементом, распаковываем его и через формат-строки выводим
print('{}, {}'.format(*base[0])) # -> Леонардо Ди Каприо, 3
print('{}, {}'.format(*base[-1])) # -> Мэтт Деймон, 1
print(base[0])

""" №4 Телефонная книга"""
# 3
# 444444 Женя
# 79129874521 Женя
# 79604845827 Оля
base = {}
for _ in range(int(input())):
    number, name = input().split()
    if name not in base:
        base[name] = int(number) # если нет - то создадим с добавлением номера
    else:
        base[name] = base[name], int(number) # если уже есть, то к старому значению добавим новое значение
                                             # образуя тем самым кортеж, Пример {'asd': (1345, 4565464)}
# 3
# Оля
# Олег
# Женя
for _ in range(int(input())):
    name = input()
    if name in base:
        if type(base[name]) == tuple:
            print(*base[name])
        else:
            print(base[name])
    else:
        print('Неизвестный номер')


""" №5 Нужно расположить таксистов в порядке убывания их средней оценке и вывести имя каждого таксиста и его среднюю 
оценку в отдельной строке. В случае совпадения средних оценок нужно расположить каждую группу таксистов, 
имеющих одинаковый рейтинг,  по имени в алфавитном порядке """
# Джек, 2
# Джек, 3
# Билл, 5
# Билл, 4
# Билл, 4
# Билл, 3
# конец
base = {}
for i in iter(input, 'конец'): # если вводим слово 'конец' - то итерация заканчивается
    # Функция iter() возвращает объект итератора.
    # Первый аргумент object интерпретируется по-разному, в зависимости от наличия второго аргумента sentinel.
    # Если НЕТ аргумента sentinel, то первый аргумент object должен быть объектом-коллекцией, которая поддерживает
    # протокол итераций метод __iter__() или он должен поддерживать протокол последовательности метод __getitem__() с целыми
    # аргументами, начиная с 0. Если он не поддерживает любой из этих протоколов, бросается исключение TypeError.
    # Если передается аргумент sentinel, то ожидается, что первый аргумент object, поддерживает вызов __call__().
    # В этом случае, созданный итератор будет вызывать указанный объект с каждым обращением к своему __next__() и
    # проверять полученное значение на равенство со значением, переданным в аргумент sentinel. Если полученное значение
    # равно sentinel, то бросается исключение StopIteration, иначе возвращается полученное значение.
    k, v = i.split(', ') # разбиваем строк на список и сохраняем части в свои переменные
    base.setdefault(k, []).append(int(v)) # обращаемся к словарю по ключу, если нет - создаём пустой список
[print(k, sum(v) / len(v)) for k, v in sorted(base.items(), key=lambda item: (-(sum(item[1]) / len(item[1])),item[0]))]
# Билл 4.0
# Джек 2.5

