# Методы __iter__ и __next__ позволяют сделать наши экземпляры - итерируемыми объектами. Это значит, что мы можем
# использовать экземпляры класса, например в цикле for. Чтобы понять, как пользоваться данными методами, вам нужно
# разобраться в том, в какой момент активируются эти методы, и какие условия важны чтобы объект стал итерируемым.

# Любой итератор всегда содержит метод __iter__ и __next__ .
# Давайте рассмотрим пример, и узнаем в какой момент они активируются во время итераций
class MyClass:    # представим, что мы объявили методы __iter__ и __next__
    pass
my = MyClass()
for i in my:    # код цикла
    pass
# Когда запускается for i in my происходит вот что:

# Сначала вызывается метод __iter__ и всё, что объявлено внутри этого метода, в конце возвращаем итератор.
# Вызывается метод __next__ и всё, что объявлено внутри этого метода.
# Вызывается "код цикла", например print(i).
# Далее повторяется пункт 2 и 3, потом опять 2 и 3 до тех пор, пока не вызовется исключение StopIteration в
# методе __next__. Исключение StopIteration всегда прописывается в методе __next__.

# К методу __iter__ мы обращаемся только один раз, а к методу __next__ мы обращаемся с каждой новой итерацией,
# это важно понимать. Количество итераций зависит от объекта, по которому мы итерируемся. Например, если мы
# итерируемся по списку [1, 2, 3], то 1 раз будет вызван метод __iter__ и 3 раза будет вызван метод __next__ .
# Объект, по которому будет происходить итерация, мы сами указываем в коде.

"""Важные моменты
Много раз перечитывайте этот текст, здесь кроется понимание темы __iter__ и __next__ :
В Python любой объект может быть итерируемым, если он содержит метод __iter__(), который возвращает итератор. 
Метод __iter__ должен возвращать любой объект, который реализует протокол итератора. Важно понимать, что такое итератор.
Итератор - это объект содержащий метод __next__(), который в свою очередь возвращает следующий элемент итерируемого 
объекта при каждом вызове, и бросает исключение StopIteration, когда элементы закончились.
Чтобы сделать экземпляр итерируемым, достаточно объявить в классе метод __iter__, который будет возвращать итератор. 
Но важно понимать, что итератором может быть не каждый объект, а объект содержащий в себе метод __next__ ."""

# Пример 1
# Распространённый пример, в котором __iter__ возвращает сам экземпляр и реализован __next__ .
class MyIterator:
    def __init__(self, data):
        self.data = data  # итерируемый объект
        self.index = 0    # счётчик итераций
    def __iter__(self):
        return self
    def __next__(self):   # код ниже, запускается при каждой итерации
        if self.index >= len(self.data):
            self.index = 0
            raise StopIteration
        item = self.data[self.index]
        self.index += 1
        return item
my_iterator = MyIterator([1, 2, 3, 4, 5])
for i in my_iterator:
    print(i)
# В данном коде, метод __iter__() возвращает self, то есть сам объект, который является итератором,
# это становится возможным на основании того, что в классе реализован метод __next__().


# Пример 2
# Пример использования функции iter()
class MyList:
    def __init__(self):
        self.data = [1, 2, 3, 4, 5]
    def __iter__(self):
        return iter(self.data)
my_list = MyList()
for item in my_list:
    print(item)
# В этом примере, вызов метода __next__() происходит неявно, так как мы возвращаем функцию iter(), в которой уже
# содержится метод __next__. Этот вариант тоже работает и о нём важно знать.


# Пример 3
# Пример использования метода __iter__ с генератором:
class MyList:
    def __init__(self):
        self.data = [1, 2, 3, 4, 5]
    def __iter__(self):
        for item in self.data:
            yield item
my_list = MyList()
for item in my_list:
    print(item)
# В этом примере мы определяем метод __iter__ с помощью генератора. Генератор позволяет нам создавать итераторы
# без необходимости явного определения метода __next__. Внутри генератора мы используем ключевое слово yield
# для возврата каждого элемента списка данных.

"""Заключение
Методы __iter__ и __next__ - это не простая тема, и кому-то потребуется больше времени чтобы её понять. 
Я постарался максимально подробно описать суть этих методов. Также я рекомендую вчитываться в текст, или 
обращаться к дополнительным источникам информации по этим темам. Мой совет, выберите самый простой пример, 
и используйте его в качестве шаблона, для решения задач по этой теме."""
