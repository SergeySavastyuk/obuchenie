"""
Метод __call__ позволяет экземпляру класса быть вызываемым объектом, то есть объектом, который может быть вызван,
как функция. Экземпляр вызывается за счёт оператора вызова (скобки). Когда вызывается экземпляр, интерпретатор Python
автоматически вызывает метод "__call__" этого объекта. Это позволяет использовать экземпляр как функцию, а класс,
даже как декоратор."""

"""Синтаксис"""
# class MyClass:
#     def __call__(self, *args, **kwargs):
#         # ваш код
#         return результат
# self - имя экземпляра
# *args, **kwargs - это аргументы, которые могут быть переданы при вызове объекта

"""Пример 1. Экземпляр как функция"""
class Adder:
    def __init__(self, x):
        self.x = x
    def __call__(self, y):
        return self.x + y
adder = Adder(5)
result = adder(3)
print(result)  # Вывод: 8
# В примере, мы создаём экземпляр adder со значением 5 атрибута x. Далее, мы вызываем экземпляр adder(3) ,
# тем самым вызывая метод __call__ . Цифра 3 и присваивается аргументом y и выполняется операция return self.x + y.
# В результате получаем 8, который присваивается переменной result.
# Говоря простым языком, если мы используем скобки на экземпляре, то будет вызываться метод __call__.
# Если мы используем аргументы в момент вызова экземпляра, то мы должны это учесть, и использовать аргументы в
# самом методе, в данном случае __call__(self, y).

"""Пример 2. Класс-декоратор и __call__
Метод __call__ позволяет создавать экземпляры классов, которые можно вызывать как функции. Это делает возможным 
создание классов-декораторов, которые могут добавлять новое поведение к функциям и методам."""
class Decorator:
    def __init__(self, f):
        self.func = f  # атрибут func ссылается на my_function
    def __call__(self, *args, **kwargs):
        print("До вызова функции")
        self.func(*args, **kwargs)    # запускаем функцию
        print("После вызова функции")
@Decorator
def my_function():
    print("Работа функции my_function")
my_function()
# До вызова функции
# Работа функции my_function
# После вызова функции

# Метод __init__ важен при создании класса-декоратора, потому что его аргумент, будет ссылаться на функцию.
# В нашем примере, f будет аргументом-ссылкой на функцию my_function, которая затем будет сохранена
# в атрибуте func экземпляра. Если вы создадите __init__ без аргументов, то возникнет ошибка.
# Затем мы определяем метод __call__, который добавляет новое поведение к функции.
# Командой self.func(*args, **kwargs), мы запускаем функцию, так как ранее функция была присвоена атрибуту func.
# В результате, декоратор позволяет нам вывести сообщения до и после вызова функции.
"""Подробное описание:
Когда запускается команда my_function(), переменной f присваивается ссылка на функцию.
Создаётся атрибут func, который ссылается на f, а следовательно на саму функцию my_function(). Создание атрибута необходимо, чтобы потом запустить функцию в методе __call__.
Запускается метод __call__ и функция print("До вызова функции"). Команда self.func(*args, **kwargs) - запускает функцию my_function(), потому что self.func имеет оператор вызова (скобки). Сама функция выводит на экран текст: Работа функции my_function. Затем запускается print("После вызова функции").
В итоге мы имеем три сообщения на экране."""


"""Пример 3. Класс-декоратор и аргументы"""
class Decorator:
    def __init__(self, func):
        self.func = func
    def __call__(self, *args, **kwargs):
        result = self.func(*args, **kwargs)
        result *= 2
        print(result)
@Decorator
def my_function(x, y):
    return x + y
my_function(10, 5)  # 30
# Если функция что-то возвращает, то мы можем сохранить это в переменную. В данном примере мы сохраняем результат
# в переменную result. Так как функция my_function имеет аргументы (x, y), то команда self.func(*args, **kwargs)
# тоже должна быть с аргументами, в данном случае мы используем *args, **kwargs, иначе будет ошибка. В примере,
# мы умножаем результат полученный в функции на 2,  и получаем число 30.

"""Важные моменты
Если экземпляр вызывается как функция, то метод "__call__" должен быть определен внутри класса.
Если при вызове экземпляра как функцию, мы используем аргументы, то это должно быть учтено в методе __call__ (пример 1).
Метод "__call__" может возвращать значения, так же как и обычные функции, если экземпляр используется как функция.
При использовании класса, как декоратора, важно объявить метод __init__ и __call__. Метод __init__ должен иметь хотя бы 
один аргумент, например __init__(self, func). Для вызова функции, в методе __call__ мы будем вызывать переменную, 
которой присвоили функцию, в примере это команда self.func(*args, **kwargs). При этом, важно учесть наличие аргументов 
в самой функции, поэтому можно использовать *args, **kwargs или свои аргументы.
Классы, которые реализуют метод "__call__", могут быть использованы в различных ситуациях, таких как обработка событий, 
создание декораторов или реализация функционального программирования."""