""" строка - неизменяемый объект. Поэтому любой вызов метода строки не изменяет первоначальный объект """

# Данный метод переводится как количество.
# С помощью метода count вы можете посчитать сколько раз вам встретилась строка sub в строке S
"""Метод .count имеет следующий шаблон вызова:
S.count(sub[, start[, end]]) """


# Метод .find возвращает индекс первого слева вхождения строки sub в строке S.
# Подстрока sub ищется на всем срезе строки S. Но вы можете указать интервал поиска,
# передав второй и третий аргументы. Метод .find вернет значение -1, если ничего не будет найдено.
"""Метод .find имеет следующий шаблон вызова:
S.find(sub[, start[, end]])"""


# Если вам необходимо искать с другого конца вашей строки, то в таком случае можно использовать
# аналогичный метод rfind(). Буква r обозначает слово right(справа) и, следовательно, поиск будет идти справа.
# Вы также можете ограничить интервал поиска, передав дополнительно параметры start и end
"""Метод .rfind имеет следующий шаблон вызова:
S.rfind(sub[, start[, end]])"""


# Метод  .index также возвращает индекс первой найденной подстроки, аналогично методу .find
"""Метод .index имеет следующий шаблон вызова:
S.index(sub[, start[, end]])"""


# Возвращает копию исходной строки  S, в которой все подстроки old заменены на подстроки new
"""Метод .replace имеет следующий шаблон вызова:
S.replace(old, new[, count])"""


# удаляет все гласные буквы,
# перед каждой согласной буквой ставит символ ".",
# все прописные согласные буквы заменяет на строчные.
print('',*[i for i in input().lower() if i not in 'aeiuoy'], sep='.')  # Codeforces -> .c.d.f.r.c.s


# Метод .split выполняет разбиение исходной строки S на подстроки по разделителю sep и возвращает их в виде списка.
# метод split - из строки получаем список
"""Метод .split  имеет следующий шаблон вызова:
S.split(sep=None, maxsplit=-1)"""
print('1, 2, 3, 4, 5'.split(', ')) # -> ['1', '2', '3', '4', '5']
# Также можно передать вторым параметром maxsplit какое максимальное количество разбиений вы хотите выполнить
print('1, 2, 3, 4, 5'.split(', ', maxsplit=2)) # -> ['1', '2', '3, 4, 5']
stoka = 'мама мыла раму'
print(stoka.split()) # -> ['мама', 'мыла', 'раму'] разбиваем по пробелам
print(stoka.split("л")) # -> ['мама мы', 'а раму'] разбиваем по указанному символу
print(stoka.split("а")) # -> ['м', 'м', ' мыл', ' р', 'му'] разбиваем по указанному символу
stoka = '1,2,3,4,5,6'
print(stoka.split(",")) # -> ['1', '2', '3', '4', '5', '6']  разбиваем по указанному символу
stoka = 'aaa'
print(stoka.split("a")) # -> ['', '', '', ''] разбиваем по указанному символу
#print(input().split())  # часто используется для получения списка из введенных значений


# Метод .join является противоположностью метода .split.
# метод join - из элементов СПИСКА получаем строку
# При помощи него вы можете разбитую строку вновь собрать в одно целое.
# Перед первым элементом и после последнего строка-разделитель проставлена не будет.
"""Метод .join  имеет следующий шаблон вызова:
S.join(iterable)"""
print('&'.join('hello world')) # -> h&e&l&l&o& &w&o&r&l&d
s = ['1', '2', '3', '4', '5', '6']
print(' '.join(s))  # -> 1 2 3 4 5 6 из элементов списка получаем строку, с указанием разделителя
print(''.join(s))  # -> 123456 из элементов списка получаем строку
print('-'.join(s))  # -> 1-2-3-4-5-6 из элементов списка получаем строку
s = (45,69,37,264,5889,31,11,4) # если список НЕ состоит из строк
print(' + '.join([str(i) for i in s])) # -> 45 + 69 + 37 + 264 + 5889 + 31 + 11 + 4перебор с преобразованием


# Данный метод возвращает True если строка S начинается с последовательности символов prefix (префикса)
# и False в противном случае.  При передаче параметра start проверка начнется именно с этой позиции.
# Если передать значение  end, проверка закончится в этой позиции.
"""Метод .startswith  имеет следующий шаблон вызова:
S.startswith(prefix[, start[, end]])"""


# Данный метод возвращает True если строка S заканчивается последовательностью символов prefix (префикса)
# и False в противном случае.
"""Метод endswith() имеет следующий шаблон вызова:
S.endswith(prefix[, start[, end]])"""


# В отдельных строках вводится три значения: сперва строка s, затем строка prefix и потом postfix.
# Нужно вывести True, если введенная строка s одновременно начинается со строки prefix и заканчивается строкой postfix .
# Во всех остальных случаях нужно вывести False. Регистр букв нужно учитывать
print(all([x := input(), x.startswith(input()), x.endswith(input())]))


# Данный метод возвращает True , если строка S не пустая и состоит только из алфавитных строчных(нижний регистр) букв.
# Если в строке имеется хотя бы одна заглавная буква, будет возвращено False.
# Все символы цифр или знак пунктуации игнорируются в проверках.
"""Метод .islower  имеет следующий шаблон вызова:
S.islower()"""


# Данный метод возвращает True , если строка S не пустая и состоит только из алфавитных заглавных(верхний регистр) букв.
# Если в строке имеется хотя бы одна строчная буква, будет возвращено False.
# Все символы цифр или знак пунктуации игнорируются в проверках.
"""Метод .isupper  имеет следующий шаблон вызова:
S.isupper()"""


# Данный метод возвращает True , если строка S не пустая и состоит только из десятичных цифр и символов,
# которые так же относятся к цифрам. В случае, если встретится другой символ, вернется False
"""Метод .isdigit  имеет следующий шаблон вызова:
S.isdigit()"""


# Данный метод возвращает True , если строка S не пустая и состоит только из букв.
"""Метод .isalpha  имеет следующий шаблон вызова:
S.isalpha()"""


# Данный метод возвращает True , если строка S не пустая и состоит только из букв и цифр.
# Если в строке имеется хотя бы один не буквенный и не числовой символ, то будет возвращено False
"""Метод .isalnum  имеет следующий шаблон вызова:
S.isalnum()"""


# Данный метод возвращает True , если строка S не пустая и является строкой заголовков:
# каждое новое слово начинается с заглавной буквы
"""Метод .istitle  имеет следующий шаблон вызова:
S.istitle()"""


# Метод  .ljust принимает один обязательный параметр width - ширину строки и один необязательный параметр fillchar
# - знак заполнителя (по умолчанию пробел) . Возвращает новую строку, в которой исходная строка S дополнена справа
# символами fillchar до указанной длины width. Если параметр width меньше длины строки, то будет возвращена исходная
# строка без изменений
"""Метод .ljust  имеет следующий шаблон вызова:
S.ljust(width[, fillchar])"""
print('qwerty'.ljust(10, '-')) # -> qwerty----


"""Метод .rjust  имеет следующий шаблон вызова:
S.rjust(width[, fillchar])"""
print('qwerty'.rjust(10, '-')) # -> ----qwerty


"""Метод .center  имеет следующий шаблон вызова:
S.center(width[, fillchar])"""
print('qwerty'.center(13, '?')) # -> ????qwerty???


# Метод .zfill возвращает новую строку, в которой исходная строка S дополнена нулями слева так,
# чтобы длина новой строки стала равна width.
"""Метод .zfill  имеет следующий шаблон вызова:
S.zfill(width)"""
print('123'.zfill(6)) # -> 000123

"""методы"""
print('12345'.ljust(10, '-'))  # 12345-----
print('12345'.rjust(10, '-'))  # -----12345
print('12345'.center(10, '-')) # --12345---
print('12345'.zfill(8))        # 00012345


# Метод  .strip возвращает копию строки, удаляя как начальные, так и конечные символы (в зависимости от переданного
# строкового аргумента). Метод удаляет символы как слева, так и справа в зависимости от аргумента chars .
# Если аргумент chars не передан, то по умолчанию удаляться пробелы и символы переноса на новую строку \n
# Символы в параметре chars рассматриваются не как последовательность, а как набор символов, которые необходимо удалить.
"""Метод .strip  имеет следующий шаблон вызова:
S.strip([chars])"""


# Метод  .rstrip возвращает копию строки, в которой справа удалены указанные символы
# (по умолчанию удаляются пробельные символы).
"""Метод .rstrip  имеет следующий шаблон вызова:
S.rstrip([chars])"""


# Метод  .lstrip возвращает копию строки, в которой слева удалены указанные символы
# (по умолчанию удаляются пробельные символы).
"""Метод .lstrip  имеет следующий шаблон вызова:
S.lstrip([chars])"""


# Метод  .partition разбивает строку по указанному разделителю и возвращает кортеж из трех элементов:
# строка до разделителя, сам разделитель и строка после разделителя. Если разделитель не найден, то возвращается
# кортеж так же состоящий из трех элементов в котором первый элемент – это исходная строка S,
# два других элемента – это пустые строки.
"""Метод .partition  имеет следующий шаблон вызова:
S.partition(sep)"""
print("Python is best".partition('is ')) # ('Python ', 'is ', 'best')
print("Python is best".partition('not ')) # ('Python is best', '', '')


"""Метод .rpartition  имеет следующий шаблон вызова:
S.rpartition(sep)"""
print("Python is best".rpartition('is ')) # ('Python ', 'is ', 'best')
print("Python is best".rpartition('not ')) # ('', '', 'Python is best')


""" RGB кодировка и обратно"""
#43ABF0 -> RGB(67, 171, 240)
#FF0000 -> RGB(255,0,0)


"""на входе три числа (0,255,10) обозначающий цвет, нужно закодировать оттенки цветов согласно RGB модели"""
r,g,b =  (int(input()) for i in '___')
r = hex(r)[2:].upper().rjust(2,'0')
g = hex(g)[2:].upper().rjust(2,'0')
b = hex(b)[2:].upper().rjust(2,'0')
print('#'+r+g+b)
# другой способ hex() переводит в 16-ую систему '0x00', первых два символа не нужны
print('#', *[hex(int(input()))[2:].upper().rjust(2, '0') for i in '___'], sep='')
# третий способ через F строку очень интересный код !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
print('#{:02X}{:02X}{:02X}'.format(*(int(input()) for _ in '___')))


number = 1024
print(f"{number:#0x}")  # 0x400




a = 'hi world'
print(f'фраза: {a}')
print(repr(a)) # метод ковычек для фраз:     'hi world'
print(f'фраза: {a!r}') # или так             фраза: 'hi world'