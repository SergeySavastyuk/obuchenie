""" Для открытия файлов существует специальная функция open """

def open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True):
    pass
# Она может принимать несколько аргументов, но только один из них обязательный - file.
# При помощи параметра file указывается путь к файлу и его название.
# Если ваш файл лежит в той же папке, где запускается программа на python,
# то в параметр file достаточно передать только название файла.
"""Если вы видите в выводе непонятные символы, это значит функция open не смогла правильно раскодировать кириллицу. 
Чтобы помочь ей правильно раскодировать русские буквы, нужно передать название кодировки utf-8 в аргумент encoding"""
file = open(r'C:\Users\User\Desktop\запрос.txt', encoding='utf-8')
print(file.read())


""" Методы файлов """

""" Метод .read  имеет следующий шаблон вызова
    file.read(n: int = -1)  
    Метод .read позволяет прочитать содержимое файла или его часть.
    Если не передавать аргумент n, то будет считано все содержимое файла сразу."""

print(file.read()) # весь файл, и курсов остаётся в конце, пока не закроют файл или не переместят курсор
print(file.read(7)) # указанная часть файла и курсор там и остаётся


""" Метод seek - можно передвинуть место курсора в файле"""
file.seek(0) # курсор переместится в начало


""" Метод .readline - позволяет считывать информацию из файла построчно"""
print(file.readline())
print(file.readline().strip())
# Дополнительный пробел при выводе возникает, потому что сама строка файла заканчивается символом переноса
# и функция print после выполнения делает перенос.
# Принято при считывании строки файла избавляться от знаков переноса при помощи метода строк .strip


""" Метод .readlines - позволяет считать файл целиком и по строкам, записав каждую строку при этом в список. 
Этот список можно использовать дальше как вам угодно, например, в качестве итерируемого объекта в цикле. """
print(file.readlines()) # получим список из строк с которым можно работать


""" Метод .write - Он должен принимать строку, которую вы хотите записать в файл"""
file = open('my_file.txt', mode='w', encoding='utf-8') # поменяем режим открытия файла на запись
print(file.write('Hello world'))
# После запуска программ метод .write  перезатрет все содержимое файла новыми значениями.
# Также обратите внимание, что метод .write не добавляет переносы на новые строки, вы должны будете сами добавлять
# при помощи служебного символа \n, который отвечает за перенос строки.
# При попытке записать информацию в несуществующий файл, никакой ошибки не будет.
# Функция open создаст файл с таким название в той же папке, где находится ваш модуль
"""Если вы хотите, чтобы содержимое файла не пропадало, а новые значения записывались в конец файла, 
необходимо открыть файл в режиме a"""
file = open('my_file.txt', mode='a', encoding='utf-8')

""" Метод close - закрывает файл """
file.close()
# в случае возникновения ошибки в обработке файла, файл не закроется, даже несмотря на наличие метода .close.


""" Режимы доступа """
# r: открывает файл в режиме «только для чтения». Этот режим применяется по умолчанию для функции open. Чтение файла начинается с начала
# rb: открывает файл в режиме «только для чтения» в двоичном формате и начинает чтение с начала файла. Буква b обозначает слово binary(двоичный). Хотя двоичный формат можно использовать для разных целей, обычно он используется при работе с такими вещами, как изображения, видео и т. д.
# r+: открывает файл для чтения и записи, помещая указатель в начало файла.
# w: открывается в режиме «только для записи». Указатель помещается в начало файла, и это перезапишет любой существующий файл с таким же именем. Он создаст новый файл, если файл с таким именем не существует.
# wb: открывает файл в режиме «только для записи» в двоичном режиме.
# w+: открывает файл для записи и чтения.
# wb+: открывает файл для записи и чтения в двоичном режиме.
# a: открывает файл для добавления к нему новой информации. Указатель помещается в конец файла. Новый файл создается, если файл с таким именем не существует.
# ab: открывает файл для добавления в двоичном режиме.
# a+: открывает файл как для добавления, так и для чтения.
# ab+: открывает файл как для добавления, так и для чтения в двоичном режиме.


"""Напишите функцию file_read, которая принимает имя файла, и печатает его содержимое.Напишите функцию file_read, 
которая принимает имя файла, и печатает его содержимое."""
def file_read(file_name: str) -> None:
    with open(file_name) as file:
        print(file.read())

"""Напишите функцию file_n_lines, которая печатает первые n-строка файла"""
def file_n_lines(file_name: str, n: int) -> None:
    with open(file_name,'r',encoding='utf-8') as file:
        [print(file.readline().strip()) for _ in range(n)]

"""Напишите функцию longest_word_in_file, которая принимает имя файла и внутри его содержимого находит самое 
длинное слово и возвращает его в качестве ответа. В случае,  если есть несколько слов с максимальной длиной, 
нужно вернуть слово, которое встречается последнее в тексте.
При этом слова в тексте отделяются друг от друга пробелами, любые другие знаки пунктуации необходимо исключить."""
from string import punctuation # модуль содержит символы пунктуации
def longest_word_in_file(file_name: str) -> str:
    with open(file_name, 'r', encoding='utf-8') as file:
        max_word = ''
        file = file.read()
        for i in punctuation:
            file = file.replace(i,'')
        file = file.strip().split()
        for word in file:
            if len(word)>=len(max_word):
                max_word=word
    return max_word

""" Примеры использования менеджера контекста """

import os
with os.scandir('.') as entries: # Функция os.scandir позволяет сканировать текущую папку и всё содержимое её помещается в entries.
    # Если вместо '.' поставить '..', то мы выйдем на папку выше.
    for entry in entries:
        print(entry.name, '->', entry.stat().st_size, 'bytes') # Функция stat() модуля os получает статистическую
        # информацию файла или дескриптора файла. А st_size выводит размер файла


""" Рассмотрим ещё один пример из темы блокировок: у блокировки есть два метода:
    balance_lock.acquire() – поставить блокировку
    balance_lock.release() – убрать блокировку 
Вместо их использования можно воспользоваться контекстным менеджером: он автоматически вызовет метод acquire, 
при этом его даже не нужно писать и так же автоматически вызовет метод release, когда блок закончится."""
import threading
balance_lock = threading.Lock()
with balance_lock:
    pass

"""Напишите функцию find_lines_len_more_6, которая принимает имя файла и находит количество строк, 
превышающее 6 символов. Не забывайте исключать знак переноса на новую строку, стоящий в конце строки.
Функция find_lines_len_more_6 должна возвращать найденное количество строк"""
def find_lines_len_more_6(file_name:str) -> int:
    with open(file_name, 'r', encoding='utf-8') as file:
        return sum(len(s) > 7 for s in file)


"""В вашем распоряжении имеется следующий файл. Ваша задача скачать его и найти сколько уникальных слов используется 
в этом тексте, при этом регистр букв не нужно учитывать. Это значит, что слова Lorem и loRem являются эквивалентными"""
import requests # библиотека
url = 'https://stepik.org/media/attachments/course/63085/lorem.txt' # адрес файла
print(len(set(requests.get(url).text.lower().split())))
# requests.get(url).text  - получаем по юрл-адресу файла его содержание


"""В вашем распоряжении имеется файл lorem.txt. Ваша задача посчитать сколько раз встретилось каждое слово в этом тексте
Для этого создайте словарь words, где ключом будет слово, а значением - количество раз появления этого слова в тексте. 
Регистр букв в словах учитывать не нужно, поэтому слова Hello и hEllO являются эквивалентными. 
Значения ключа в словаре words записывайте в верхнем регистре"""
with open('lorem.txt', encoding='utf-8') as f:
    words = {}
    for i in f.read().split():
        words[i.upper()] = words.get(i.upper(), 0) + 1
# другое решение через генератор словаря
with open(r'lorem.txt','r', encoding='utf-8') as f_in:
    ls = f_in.read().upper().split()
    words={s: ls.count(s) for s in set(ls)}


"""В этой задаче вам необходимо обработать файл с названием words.txt, содержащий множество неуникальных слов.
Само содержимое файла можно посмотреть здесь. Ваша задача найти в нем все слова, заканчивающиеся на строку ЕЯ,
и вывести их на экран. При этом нужно:
исключить дубли
привести все буквы к верхнему регистру
расположить слова в выводе в порядке двойной сортировки: сперва отсортировать по возрастанию длины слова,
а при одинаковых значениях длины расположить по алфавиту"""
with open('words.txt', 'r', encoding='utf-8') as file:
    print(*sorted(set([word.upper() for word in file.read().split() if word.upper()[-2:] == 'ЕЯ']),key=lambda x: (len(x), x)),sep='\n')











