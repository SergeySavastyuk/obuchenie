"""
__add__      # используется для определения оператора сложения (+) между объектами
__sub__      # используется для определения оператора вычитания (-) между объектами
__mul__      # используется для определения оператора умножения (*) между объектами
__pow__      # является специальным методом, который позволяет возвести в степень объект
__truediv__  # используется для определения оператора деления (/) между объектами
__abs__      # вызывается при использовании встроенной функции abs() для объекта"""

# Специальный метод __add__ используется для сложения (+) объектов.
# Он позволяет нам складывать экземпляры с экземплярами, числами, строками и др. У метода __add__ есть
# "дополнительные" методы __radd__ и __iadd__ , они также используются в сложении, расширяя функционал вашего кода.
# При выборе __add__ , __radd__ и __iadd__ , важно понимать, с какой стороны находится экземпляр в математической
# операции и используется ли оператор += . Например:

# result1 = экземпляр + 100  # используется __add__
# result2 = 100 + экземпляр  # используется __radd__
# экземпляр += экземпляр     # используется __iadd__
# экземпляр += 100           # используется __iadd__
# result1: экземпляр находится слева, поэтому используется метод __add__,
# result2: экземпляр находится справа, поэтому используется метод __radd__. Буква r - означает right (справа).
# А когда присутствует оператор += , используется метод __iadd__.

# Синтаксис
# def __add__(self, other):
#     # код, определяющий сложение объектов
#     return результат_сложения
#
# def __radd__(self, other):
#     # код, определяющий сложение объектов
#     return результат_сложения
#
# def __iadd__(self, other):
#     # код, определяющий сложение объектов
#     return self
# self - это объект, к которому применяется метод
# other - это объект, с которым производится сложение.
#
# Пример 1. __add__ экземпляр слева
class Number:
    def __init__(self, number):
        self.number = number
    def __add__(self, other):
        return self.number + other
num1 = Number(2)
result1 = num1 + 88  # выполняется __add__(num1, 88)
print(result1)       # 90
result2 = 88 + num1  # ошибка
# Когда выполняется команда num1 + 88, интерпретатор вызывает метод __add__ , так как экземпляр в операции слева.
# Команда result = 88 + num1 - вызовет ошибку, потому что экземпляр находится справа, а метод __radd__ не объявлен.

# Пример 2. __radd__ экземпляр справа
class Number:
    def __init__(self, number):
        self.number = number
    def __radd__(self, other):
        return self.number + other
num1 = Number(2)
result1 = 3 + num1   # вызовет __radd__ , так как экземпляр справа в операции сложения
print(result1)       # 5
# Когда выполняется команда 3 + num1, интерпретатор вызывает метод __radd__ , так как экземпляр в операции справа.

# Пример 3. Сложение Экземпляров
class Number:
    def __init__(self, number):
        self.number = number
    def __add__(self, other):
        if isinstance(other, Number):
            return self.number + other.number
        elif isinstance(other, int):
            return self.number + other
    def __radd__(self, other):
        if isinstance(other, int):
            return self.number + other
num1 = Number(10)
num2 = Number(20)
num3 = Number(30)
result1 = num1 + num2 + num3
print(result1)  # 60

# Пример 4. Оператор "+=" и __iadd__
# Если вы желаете использовать += в своих операциях, то нужно объявить __iadd__. В Python, префикс "i" в названии
# метода __iadd__ означает "in-place add", что означает, что этот метод выполняет операцию сложения с присваиванием
# "в месте" (in-place). Это означает, что метод изменяет текущий объект, а не создает новый объект.

class Number:
    def __init__(self, number):
        self.number = number
    def __iadd__(self, other):
        if isinstance(other, Number):
            self.number += other.number
            return self
        if isinstance(other, int):
            self.number += other
            return self
num1 = Number(10)
num2 = Number(20)
num1 += num2
print(num1.number)  # 30
num1 += 40
print(num1.number)  # 70
# В примере мы проводим проверку, объясняем интерпретатору как складывать объекты и возвращаем self.
# Отличие от других примеров, важно возвращать именно self.