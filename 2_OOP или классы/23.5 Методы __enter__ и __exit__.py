"""С помощью методов __enter__ и __exit__, мы можем работать с контекстным менеджером with,
используя классы или экземпляры.  Сам контекстный менеджер позволяет выполнять такие операции,
как открытие и закрытие файлов, работа с сетевыми подключениями, соединение с базами данных. Для лучшего понимания,
повторите тему with, если совсем не понимаете, что это такое."""

# Последовательность вызовов методов
# Давайте рассмотрим пример, чтобы понять последовательность вызовов методов, при работе с with.
# На аргументы в __exit__ пока не обращайте внимания, это стандартная запись.
class File:
    def __init__(self):
        print(f'вызвали __init__')
    def __enter__(self):
        print('вызвали __enter__')
    def __exit__(self, exc_type, exc_value, traceback):
        print('вызвали __exit__')
with File():
    print('вызвали ваш блок кода в with')
# В примере, мы создали класс File, и объявили три метода: __init__, __enter__ и __exit__.
# Каждый метод выводит на экран текстовую информацию. С оператором with мы используем класс File().
# В результате, мы видим последовательность вызовов:
"""
вызвали __init__ и какой-то текст
вызвали __enter__
вызвали ваш блок кода в with
вызвали __exit__"""
# Пока важно, чтобы вы просто понимали последовательность, далее мы разберём разные ситуации более детально.


# Пример с экземпляром
# Последовательность мы поняли, теперь давайте разберём как работать с экземпляром и с методом __enter__.
class File:
    def __init__(self, text):
        self.text = text
    def __enter__(self):
        return f'{self.text} и __enter__'
    def __exit__(self, exc_type, exc_value, traceback):
        pass
sample = File('ваш текст')
with sample as method_enter:
    print(method_enter)  # ваш текст и __enter__
# В примере три метода. В методе __init__ мы создаём атрибут text, здесь всё стандартно.
# В методе __enter__ мы возвращаем значение атрибута text и текст. Метод __exit__ пока ничего не делает.
# Далее, создаём экземпляр sample и присваиваем значение 'ваш текст' атрибуту text.  С оператором with используем
# экземпляр sample как переменную method_enter. Вот здесь важный момент, на самом деле в переменную method_enter
# сохраняется то, что мы возвращаем в методе __enter__ , поэтому я так и назвал переменную.
# Далее, мы вызываем команду  print(method_enter) и действительно убеждаемся в этом (см. результат).
# Получается, что в блоке кода, мы будем работать с тем, что возвращает нам метод __enter__, это важно понимать.

# Пример с классом
# Всё тоже самое можно сделать, не создавая экземпляр, а используя класс.
class File:
    def __init__(self, text):
        self.text = text
    def __enter__(self):
        return f'{self.text} и __enter__'
    def __exit__(self, exc_type, exc_value, traceback):
        pass
with File('ваш текст') as method_enter:
    print(method_enter)  # ваш текст и __enter__
# В примере, мы используем вместо экземпляра, класс File с аргументом 'ваш текст'.
# Данный пример может показаться странным, ведь обычно, создавая экземпляр мы присваиваем его какой-то переменной
# (sample, прошлый пример). Конкретного ответа у меня нет, и в интернете пока тоже не нашел, могу лишь предположить,
# что создаётся временный экземпляр и в нём появляется атрибут text, а далее, как в предыдущем примере.

"""Синтаксис:
def __enter__(self):
    # Код, который должен быть выполнен до блока
    return self

def __exit__(self, exc_type, exc_value, traceback):
    # Код, который должен быть выполнен после блока"""
# Метод __enter__ вызывается в начале блока кода, и он возвращает объект, который может быть
# использован внутри блока (см. пример с method_enter).
# Метод __exit__ вызывается в конце блока кода, и он отвечает за очистку любых ресурсов,
# которые были использованы внутри блока. Аргументы: exc_type (тип исключения), exc_value (значение исключения) и
# traceback (след вызовов функций). На аргументы пока не обращайте внимание.
"""Важные моменты
Важно, чтобы вы понимали последовательность вызовов методов.
С оператором with можно использовать и класс, и экземпляр.
Метод __enter__ должен возвращать объект, который будет связан с переменной внутри контекстного блока кода. 
Этот объект может быть использован для выполнения операций внутри блока кода (см. пример с method_enter).
Метод __exit__ вызывается при выходе из контекстного блока кода, независимо от того, было ли исключение или нет.
Чуть больше про __exit__, кому интересно. Он принимает три аргумента: exc_type (тип исключения), 
exc_value (значение исключения) и traceback (след вызовов функций). Если исключение было возбуждено в блоке кода, 
оно будет передано в метод __exit__ в качестве аргументов exc_type, exc_value и traceback.
Если метод __exit__ возвращает True, то исключение будет подавлено и выполнение программы продолжится после 
контекстного блока кода. Если метод __exit__ возвращает False или вызывает исключение, 
то исключение будет повторно поднято после выполнения контекстного блока кода."""


# Разбор примеров
# Данные примеры являются узконаправленными, поэтому достаточно, чтобы вы поняли хотя бы пример 1.

# Пример 1
# Использование контекстного менеджера для работы с файлом:
class File:
    def __init__(self, filename):
        self.filename = filename
    def __enter__(self):
        self.file = open(self.filename, 'r')
        return self.file
    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()
with File('example.txt') as f:
    for line in f:
        print(line)
# Создается класс File.
# В классе определяется метод __init__, который принимает аргумент filename и присваивает его значение атрибуту
# self.filename.
# В классе определяется метод __enter__, который открывает файл с именем, указанным в self.filename в режиме чтения
# ('r') и возвращает открытый файл.
# В классе определяется метод __exit__, который закрывает файл.
# Создается контекстный менеджер с использованием ключевого слова with, который создает экземпляр класса File и
# присваивает значение 'example.txt' атрибуту filename.
# Переменной f присваивается открытый для чтения файл.
# В блоке контекстного менеджера for проходим по каждой строке в открытом файле f.
# Для каждой строки выполняется команда print, которая выводит строку на экран.
# После завершения работы с файлом контекстный менеджер автоматически закрывает файл благодаря методу exit.
# Таким образом, код открывает файл 'example.txt', читает его построчно и выводит каждую строку на экран,
# после чего автоматически закрывает файл.

# Пример 2
# Использование контекстного менеджера для работы с сетевым соединением:
import socket
class NetworkConnection:
    def __init__(self, host, port):
        self.host = host
        self.port = port
    def __enter__(self):
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.connect((self.host, self.port))
        return self.connection
    def __exit__(self, exc_type, exc_value, traceback):
        self.connection.close()
with NetworkConnection('localhost', 8080) as conn:
    conn.send(b'Hello, server!')
    response = conn.recv(1024)
    print(response)
# Импортируется модуль socket.
# Создается класс NetworkConnection с конструктором __init__, который принимает параметры host и port и сохраняет их
# в атрибуты self.host и self.port соответственно.
# Определяется метод __enter__, который устанавливает соединение с сервером. Внутри метода создается сокет
# socket.socket, указывается семейство адресов AF_INET и тип сокета SOCK_STREAM. Затем вызывается метод connect для
# установки соединения с указанным хостом и портом, после чего возвращается объект соединения self.connection.
# Определяется метод __exit__, который закрывает соединение при выходе из блока контекста. Если возникло исключение
# (exc_type, exc_value, traceback), оно обрабатывается, и соединение все равно закрывается.
# Используется оператор with для создания экземпляра класса NetworkConnection с параметрами 'localhost' и 8080.
# Это вызывает метод enter для установления соединения, которое сохраняется в переменную conn.
# Отправляется сообщение серверу с помощью метода send объекта conn, преобразованное в байтовый формат b'Hello,server!'.
# Получаем ответ от сервера с помощью метода recv объекта conn, который сохраняется в переменной response.
# Выводится ответ сервера на экран с помощью функции print.

# Пример 3
# Использование контекстного менеджера для управления транзакциями в базе данных:
import sqlite3
class DatabaseTransaction:
    def __init__(self, database):
        self.database = database
    def __enter__(self):
        self.connection = sqlite3.connect(self.database)
        self.cursor = self.connection.cursor()
        return self.cursor
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            self.connection.commit()
        else:
            self.connection.rollback()
        self.cursor.close()
        self.connection.close()
with DatabaseTransaction('example.db') as cursor:
    cursor.execute('SELECT * FROM users')
    results = cursor.fetchall()
    for row in results:
        print(row)
# Импортируется модуль sqlite3.
# Создается класс DatabaseTransaction с конструктором __init__, который принимает параметр database и сохраняет его
# в атрибут self.database.
# Определяется метод __enter__, который устанавливает соединение с базой данных. Внутри метода создается соединение
# sqlite3.connect с указанием имени базы данных, затем создается объект курсора self.cursor для выполнения
# SQL-запросов, и он возвращается из метода.
# Определяется метод __exit__, который закрывает соединение с базой данных при выходе из блока контекста.
# Если возникло исключение (exc_type, exc_value, traceback), то выполняется откат транзакции rollback, в противном
# случае транзакция фиксируется commit. Затем закрывается курсор и соединение.
# Используется оператор with для создания экземпляра класса DatabaseTransaction с параметром 'example.db'.
# Это вызывает метод __enter__ для установления соединения с базой данных, и курсор сохраняется в переменной cursor.
# Выполняется SQL-запрос для выборки всех записей из таблицы 'users' с помощью метода execute объекта cursor.
# Результат запроса сохраняется в переменной results с помощью метода fetchall объекта cursor.
# Для каждой строки результата выводится на экран содержимое строки с помощью функции print.